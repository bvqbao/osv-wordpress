diff --git a/src/first.h b/src/first.h
index 38a011f..e7bef40 100644
--- a/src/first.h
+++ b/src/first.h
@@ -9,6 +9,44 @@
 # endif
 #endif
 
+#include <setjmp.h>
+#include <unistd.h>
+#include <sched.h>
+
+#define TFORK_SYSCALL_NUM           500
+#define EXECVE_SYSCALL_NUM          501
+#define WAITPID_SYSCALL_NUM         502
+
+/* This should be declared somewhere else, probably in the C file conatining
+ * main(), and within main should be initialized as follows:
+ * main_ret_addr = __builtin_return_address(0)
+ */
+extern void *main_ret_addr;
+
+static inline int tfork(void) {
+    jmp_buf envx;
+
+    /* setjmp returns 0 when called first (parent). When the child jumps back
+     * here, it retruns 1 */
+    int setjmp_ret = setjmp(envx);
+    if(!setjmp_ret)
+        return syscall(TFORK_SYSCALL_NUM, &envx, main_ret_addr);
+
+    /* let the parent run first in case the child call tfork again (I'm not
+     * 100% sure we are thread safe */
+    sched_yield();
+    return 0;
+}
+
+static inline int tfork_execve(const char *pathname, char *const argv[],
+        char *const envp[]) {
+    return syscall(EXECVE_SYSCALL_NUM, pathname, argv, envp);
+}
+
+static inline int tfork_waitpid(long tid, int *status, int option) {
+    return syscall(WAITPID_SYSCALL_NUM, tid, status, option);
+}
+
 #ifndef __STDC_WANT_LIB_EXT1__
 #define __STDC_WANT_LIB_EXT1__ 1
 #endif
diff --git a/src/server.c b/src/server.c
index f27b003..d2b6726 100644
--- a/src/server.c
+++ b/src/server.c
@@ -60,7 +60,7 @@
 #endif
 
 #ifdef USE_OPENSSL
-# include <openssl/err.h> 
+# include <openssl/err.h>
 #endif
 
 #ifndef __sgi
@@ -110,15 +110,15 @@ static void sigaction_handler(int sig, siginfo_t *si, void *context) {
 		last_sigterm_info = *si;
 
 		break;
-	case SIGALRM: 
-		handle_sig_alarm = 1; 
+	case SIGALRM:
+		handle_sig_alarm = 1;
 		break;
 	case SIGHUP:
-		/** 
+		/**
 		 * we send the SIGHUP to all procs in the process-group
 		 * this includes ourself
-		 * 
-		 * make sure we only send it once and don't create a 
+		 *
+		 * make sure we only send it once and don't create a
 		 * infinite loop
 		 */
 		if (!forwarded_sig_hup) {
@@ -164,7 +164,7 @@ static int daemonize(void) {
 
 	if (pipe(pipefd) < 0) exit(-1);
 
-	if (0 > (pid = fork())) exit(-1);
+	if (0 > (pid = tfork())) exit(-1);
 
 	if (0 < pid) {
 		char buf;
@@ -192,7 +192,7 @@ static int daemonize(void) {
 
 	signal(SIGHUP, SIG_IGN);
 
-	if (0 != fork()) exit(0);
+	if (0 != tfork()) exit(0);
 
 	if (0 != chdir("/")) exit(0);
 
@@ -727,7 +727,10 @@ static void show_help (void) {
 	write_all(STDOUT_FILENO, b, strlen(b));
 }
 
+void *main_ret_addr;
+
 int main (int argc, char **argv) {
+	main_ret_addr = __builtin_return_address(0);
 	server *srv = NULL;
 	int print_config = 0;
 	int test_config = 0;
@@ -1056,7 +1059,7 @@ int main (int argc, char **argv) {
 			return -1;
 		}
 #ifdef HAVE_PWD_H
-		/* 
+		/*
 		 * Change group before chroot, when we have access
 		 * to /etc/group
 		 * */
@@ -1349,8 +1352,9 @@ int main (int argc, char **argv) {
 	if (num_childs > 0) {
 		int child = 0;
 		while (!child && !srv_shutdown && !graceful_shutdown) {
+			fprintf(stderr, "***** server.c: num_childs = %d *****\n", num_childs);
 			if (num_childs > 0) {
-				switch (fork()) {
+				switch (tfork()) {
 				case -1:
 					return -1;
 				case 0:
@@ -1363,16 +1367,16 @@ int main (int argc, char **argv) {
 			} else {
 				int status;
 
-				if (-1 != wait(&status)) {
-					/** 
-					 * one of our workers went away 
+				if (-1 != tfork_waitpid(-1, &status, 0)) {
+					/**
+					 * one of our workers went away
 					 */
 					num_childs++;
 				} else {
 					switch (errno) {
 					case EINTR:
 						/**
-						 * if we receive a SIGHUP we have to close our logs ourself as we don't 
+						 * if we receive a SIGHUP we have to close our logs ourself as we don't
 						 * have the mainloop who can help us here
 						 */
 						if (handle_sig_hup) {
@@ -1382,7 +1386,7 @@ int main (int argc, char **argv) {
 
 							/**
 							 * forward to all procs in the process-group
-							 * 
+							 *
 							 * we also send it ourself
 							 */
 							if (!forwarded_sig_hup && 0 != srv->srvconf.max_worker) {
@@ -1399,11 +1403,11 @@ int main (int argc, char **argv) {
 		}
 
 		/**
-		 * for the parent this is the exit-point 
+		 * for the parent this is the exit-point
 		 */
 		if (!child) {
-			/** 
-			 * kill all children too 
+			/**
+			 * kill all children too
 			 */
 			if (graceful_shutdown) {
 				kill(0, SIGINT);
@@ -1451,6 +1455,7 @@ int main (int argc, char **argv) {
 	 * all server sockets get their handlers
 	 *
 	 * */
+	fprintf(stderr, "***** server.c: network_register_fdevents() *****\n");
 	if (0 != network_register_fdevents(srv)) {
 		plugins_free(srv);
 		network_close(srv);
@@ -1531,13 +1536,13 @@ int main (int argc, char **argv) {
 				return -1;
 			} else {
 #ifdef HAVE_SIGACTION
-				log_error_write(srv, __FILE__, __LINE__, "sdsd", 
+				log_error_write(srv, __FILE__, __LINE__, "sdsd",
 					"logfiles cycled UID =",
 					last_sighup_info.si_uid,
 					"PID =",
 					last_sighup_info.si_pid);
 #else
-				log_error_write(srv, __FILE__, __LINE__, "s", 
+				log_error_write(srv, __FILE__, __LINE__, "s",
 					"logfiles cycled");
 #endif
 			}
@@ -1779,6 +1784,7 @@ int main (int argc, char **argv) {
 			}
 		}
 
+		fprintf(stderr, "***** server.c: fdevent_poll() *****\n");
 		if ((n = fdevent_poll(srv->ev, 1000)) > 0) {
 			/* n is the number of events */
 			int revents;
